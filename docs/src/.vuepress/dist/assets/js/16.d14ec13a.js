(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{515:function(e,r,t){"use strict";t.r(r);var n=t(45),a=Object(n.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"errors"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#errors"}},[e._v("#")]),e._v(" Errors")]),e._v(" "),t("p",[e._v("When using ABS, you might bump into errors within your code. When the interpreter finds an error, it will give up trying to execute the script and will exit with status code "),t("code",[e._v("99")]),e._v(".")]),e._v(" "),t("p",[e._v("Note that there are 2 phases of the interpreter: parser and evaluator.")]),e._v(" "),t("p",[e._v("When the parser phase encounters a syntax error it will continue to process the rest of the file and report all of the syntax errors it finds.")]),e._v(" "),t("p",[e._v("However, the evaluator phase will quit immediately when it encounters an evaluation error. Thus, you may need to run the ABS interpreter multiple times to find all the run-time errors.")]),e._v(" "),t("p",[e._v("When you are running ABS interactively in the Run, Eval, Print Loop (REPL) the location of the error can only be the current line you just entered.")]),e._v(" "),t("p",[e._v("However, when you are running ABS over a script file (even a small one) locating errors requires more help from the interpreter. ABS now provides "),t("code",[e._v("[line:column]")]),e._v(" positions as well as the error line itself following the error message.")]),e._v(" "),t("p",[e._v("For example, a file with syntax errors might look like this when the first syntax error is in line 4 at column 5.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("$ cat examples/error-parse.abs\n# there are multiple parser errors in this file\n\n# this is a malformed identifier\nm.a = 'abc'\n\n# this is a command terminated with a semi\nd/d = `command`;\n\n# this is a command terminated with a LF\nc/c = `command`\n\n# this is a bad infix operator\nb %% c\n\n$ abs examples/error-parse.abs\n  parser errors:\n\tno prefix parse function for '=' found\n\t[4:5]\tm.a = 'abc'\n\tno prefix parse function for '=' found\n\t[7:5]\td/d = `command`;\n\tno prefix parse function for '=' found\n\t[10:5]\tc/c = `command`\n\tno prefix parse function for '%' found\n\t[13:4]\tb %% c\n\n$ echo $?\n99\n")])])]),t("p",[e._v("Furthermore, a file with evaluation errors might look like this when the first error encountered is in line 2 at column 3:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('$ cat examples/error-eval.abs\n# there is an evaluation error on line 2\n1 + "hello"\necho("should not reach here")\n\n$ abs examples/error-eval.abs\nERROR: type mismatch: NUMBER + STRING\n\t[2:3]\t1 + "hello"\n\n$ echo $?\n99\n')])])])])}),[],!1,null,null,null);r.default=a.exports}}]);